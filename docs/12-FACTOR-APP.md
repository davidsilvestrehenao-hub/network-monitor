# 12-Factor App Compliance Guide

This document provides a comprehensive guide to the Network Monitor's compliance with the [12-Factor App methodology](https://12factor.net/), which defines best practices for building modern, scalable, cloud-native applications.

## üìä Current Status: 8/12 ‚úÖ

| Factor | Status | Compliance |
|--------|--------|------------|
| I. Codebase | ‚úÖ | 100% Compliant |
| II. Dependencies | ‚úÖ | 100% Compliant |
| III. Config | ‚ö†Ô∏è | **Needs Improvement** |
| IV. Backing Services | ‚úÖ | 100% Compliant |
| V. Build, Release, Run | ‚úÖ | 100% Compliant |
| VI. Processes | ‚úÖ | 100% Compliant |
| VII. Port Binding | ‚úÖ | 100% Compliant |
| VIII. Concurrency | ‚úÖ | 100% Compliant |
| IX. Disposability | ‚ö†Ô∏è | **Needs Improvement** |
| X. Dev/Prod Parity | ‚ö†Ô∏è | **Needs Improvement** |
| XI. Logs | ‚ö†Ô∏è | **Needs Improvement** |
| XII. Admin Processes | ‚úÖ | 100% Compliant |

**Overall Score: 8/12 Fully Compliant, 4/12 Need Improvement**

## üöÄ Quick Reference

### Before Writing Code
- [ ] Configuration from environment variables (never hardcode)
- [ ] Services are stateless (no in-memory state)
- [ ] Logs stream to stdout/stderr (never to files)
- [ ] Backing services from environment (database, event bus)

### Before Committing
- [ ] No secrets in code or config files
- [ ] No hardcoded URLs or connection strings
- [ ] All logs use structured format (JSON)
- [ ] Tests pass with environment variables

### Before Deploying
- [ ] Environment variables documented
- [ ] Health check endpoint works
- [ ] Graceful shutdown tested
- [ ] Logs aggregation configured

---

## üìã The 12 Factors

### I. Codebase ‚úÖ

**One codebase tracked in revision control, many deploys**

```bash
# ‚úÖ Single repository, multiple deployments
git clone https://github.com/your-org/network-monitor.git

# Deploy to different environments
deploy to development
deploy to staging
deploy to production
```

**Current State:**
- ‚úÖ Single Git repository with monorepo structure
- ‚úÖ Turborepo for managing multiple apps and packages
- ‚úÖ Clear separation of concerns (apps/, packages/)
- ‚úÖ Same codebase deployed to development, staging, and production

### II. Dependencies ‚úÖ

**Explicitly declare and isolate dependencies**

```json
// ‚úÖ GOOD - package.json
{
  "dependencies": {
    "solid-js": "^1.9.3",
    "@prisma/client": "^5.22.0"
  }
}
```

```bash
# ‚úÖ Lock file committed
bun.lock

# ‚ùå BAD - Relying on system-wide packages
npm install -g some-package
```

**Current State:**
- ‚úÖ Using Bun package manager with `package.json`
- ‚úÖ Lock file (`bun.lock`) ensures consistent dependencies
- ‚úÖ Workspace dependencies properly declared
- ‚úÖ No system-level dependencies assumed

### III. Config ‚ö†Ô∏è

**Store config in the environment**

```typescript
// ‚úÖ GOOD - Environment variables
import { getEnvironment } from "@network-monitor/infrastructure";
const config = getEnvironment();
const dbUrl = config.databaseUrl;

// ‚ùå BAD - Hardcoded or JSON config
const dbUrl = "postgresql://localhost:5432/db";
const config = require("./config/production.json");
```

**Current State (Issues):**
- ‚ùå Configuration stored in JSON files (`configs/*.json`)
- ‚ùå Hard to override configs per deployment
- ‚ö†Ô∏è Some environment variables used, but not consistently
- ‚ùå JSON config files contain environment-specific settings

**Required Changes:**

**CRITICAL: Move from JSON configuration to environment variables**

```bash
# .env.example (to create)
# Database
DATABASE_URL=postgresql://user:password@localhost:5432/network_monitor

# Application
NODE_ENV=development
PORT=3000
HOST=0.0.0.0

# Services
MONITOR_SERVICE_ENABLED=true
ALERTING_SERVICE_ENABLED=true
NOTIFICATION_SERVICE_ENABLED=true

# Logging
LOG_LEVEL=info
LOG_FORMAT=json

# Event Bus
EVENT_BUS_TYPE=in-memory
RABBITMQ_URL=amqp://localhost:5672

# Auth
AUTH_SECRET=your-secret-key-here
AUTH_PROVIDERS=mock,github,google

# Monitoring
SPEED_TEST_INTERVAL=30000
ALERT_CHECK_INTERVAL=5000
```

### IV. Backing Services ‚úÖ

**Treat backing services as attached resources**

```typescript
// ‚úÖ GOOD - Service from environment
const prisma = new PrismaClient({
  datasources: { db: { url: process.env.DATABASE_URL } },
});

// ‚ùå BAD - Hardcoded backing service
const prisma = new PrismaClient({
  datasources: { db: { url: "postgresql://prod-server/db" } },
});
```

**Current State:**
- ‚úÖ Database abstracted through Prisma ORM
- ‚úÖ Repository pattern isolates data access
- ‚úÖ Event bus abstracted through interfaces
- ‚úÖ Services can switch between implementations via DI

### V. Build, Release, Run ‚úÖ

**Strictly separate build and run stages**

```bash
# ‚úÖ GOOD - Separate stages
bun run build              # Build stage
docker build -t app:v1     # Release stage
docker run app:v1          # Run stage

# ‚ùå BAD - Mixed stages
bun run build && bun run start
```

**Current State:**
- ‚úÖ Separate build and run stages
- ‚úÖ Docker support for containerized deployments
- ‚úÖ TypeScript compilation produces artifacts
- ‚úÖ No runtime compilation in production

### VI. Processes ‚úÖ

**Execute the app as one or more stateless processes**

```typescript
// ‚úÖ GOOD - Stateless
class MonitorService {
  async getTarget(id: string) {
    return this.repository.findById(id); // From database
  }
}

// ‚ùå BAD - Stateful
class MonitorService {
  private targets = new Map(); // ‚ùå In-memory state
}
```

**Current State:**
- ‚úÖ Services designed to be stateless
- ‚úÖ State stored in database, not in-memory
- ‚úÖ Event-driven architecture prevents tight coupling
- ‚úÖ Can scale horizontally

### VII. Port Binding ‚úÖ

**Export services via port binding**

```typescript
// ‚úÖ GOOD - Port from environment
const PORT = process.env.PORT || 3000;
Bun.serve({ port: PORT });

// ‚ùå BAD - Hardcoded port
Bun.serve({ port: 3000 });
```

**Current State:**
- ‚úÖ Services bind to ports specified in environment
- ‚úÖ Self-contained HTTP servers (Bun)
- ‚úÖ No external web server required
- ‚úÖ Port configuration via environment variables

### VIII. Concurrency ‚úÖ

**Scale out via the process model**

```bash
# ‚úÖ GOOD - Scale with multiple processes
docker-compose up -d --scale monitor-service=3

# ‚ùå BAD - Single process with threads
node --max-old-space-size=8192 app.js
```

**Current State:**
- ‚úÖ Multiple service types for different workloads
- ‚úÖ Can scale each service independently
- ‚úÖ Event-driven decoupling enables scaling
- ‚úÖ Stateless design supports horizontal scaling

### IX. Disposability ‚ö†Ô∏è

**Maximize robustness with fast startup and graceful shutdown**

```typescript
// ‚úÖ GOOD - Graceful shutdown
process.on("SIGTERM", async () => {
  await server.close();
  await database.disconnect();
  process.exit(0);
});

// ‚ùå BAD - Abrupt shutdown
// No signal handlers
```

**Current State (Issues):**
- ‚ö†Ô∏è Startup time is reasonable but not optimized
- ‚ö†Ô∏è Graceful shutdown implemented but needs improvement
- ‚ùå No explicit signal handling for all edge cases
- ‚ö†Ô∏è Database connections may not close gracefully

**Required Changes:**

```typescript
// Graceful shutdown handler
async function gracefulShutdown(signal: string) {
  console.log(`Received ${signal}, starting graceful shutdown...`);

  // 1. Stop accepting new requests
  server.close();

  // 2. Complete in-flight requests (with timeout)
  await Promise.race([
    completeInFlightRequests(),
    timeout(30000), // 30 second timeout
  ]);

  // 3. Close database connections
  await database.disconnect();

  // 4. Close event bus connections
  await eventBus.disconnect();

  // 5. Exit cleanly
  console.log("Graceful shutdown complete");
  process.exit(0);
}

// Register signal handlers
process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
process.on("SIGINT", () => gracefulShutdown("SIGINT"));
```

### X. Dev/prod Parity ‚ö†Ô∏è

**Keep development, staging, and production as similar as possible**

```bash
# ‚úÖ GOOD - Same database in all environments
# Development
DATABASE_URL=postgresql://localhost:5432/network_monitor_dev

# Production
DATABASE_URL=postgresql://prod-host:5432/network_monitor

# ‚ùå BAD - Different databases
# Development: SQLite
# Production: PostgreSQL
```

**Current State (Issues):**
- ‚ùå SQLite for development, PostgreSQL for production
- ‚ö†Ô∏è In-memory event bus for dev, RabbitMQ for prod
- ‚ö†Ô∏è Mock services in dev, real services in prod
- ‚ùå Significant differences in database behavior

**Required Changes:**

**CRITICAL: Improve dev/prod parity**

1. **Use PostgreSQL in development** (via Docker Compose)
2. **Optional RabbitMQ for development**
3. **Consistent environment variables**
4. **Same database schema and migrations**

```yaml
# docker-compose.dev.yml
version: "3.8"

services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: network_monitor_dev
      POSTGRES_USER: dev
      POSTGRES_PASSWORD: dev
    ports:
      - "5432:5432"
    volumes:
      - postgres_dev_data:/var/lib/postgresql/data

  rabbitmq:
    image: rabbitmq:3-management-alpine
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: dev
      RABBITMQ_DEFAULT_PASS: dev

volumes:
  postgres_dev_data:
```

### XI. Logs ‚ö†Ô∏è

**Treat logs as event streams**

```typescript
// ‚úÖ GOOD - Stream to stdout
logger.info("Event occurred", { userId, action });

// ‚ùå BAD - Write to files
fs.appendFile("app.log", message);
winston.transports.File({ filename: "error.log" });
```

**Current State (Issues):**
- ‚ö†Ô∏è Some logging to console (good)
- ‚ùå Some logging to files (violates 12-factor)
- ‚ö†Ô∏è Not all logs structured
- ‚ùå Log aggregation not standardized

**Required Changes:**

**CRITICAL: Stream all logs to stdout/stderr**

```typescript
// Remove file-based logging
// ‚ùå BAD - Writing to files
winston.createLogger({
  transports: [
    new winston.transports.File({ filename: "error.log" }),
  ],
});

// ‚úÖ GOOD - Stream to stdout
winston.createLogger({
  transports: [
    new winston.transports.Console({
      format: winston.format.json(), // Structured logging
    }),
  ],
});
```

**Structured Logging:**

```typescript
// All logs should be structured JSON
logger.info("Target created", {
  targetId: "target-123",
  userId: "user-456",
  timestamp: new Date().toISOString(),
  environment: process.env.NODE_ENV,
});

// Output:
// {"level":"info","message":"Target created","targetId":"target-123","userId":"user-456","timestamp":"2025-10-01T12:00:00Z","environment":"production"}
```

### XII. Admin Processes ‚úÖ

**Run admin/management tasks as one-off processes**

```bash
# ‚úÖ GOOD - One-off admin processes
bun run db:migrate
bun run db:seed
bun run db:reset

# ‚ùå BAD - Admin UI in main app
app.get("/admin/reset-database", async (req, res) => {
  await database.reset(); // ‚ùå Don't do this
});
```

**Current State:**
- ‚úÖ Database migrations run as separate processes
- ‚úÖ Seed scripts are one-off processes
- ‚úÖ Admin tasks use same codebase and config
- ‚úÖ Scripts properly use environment variables

---

## üéØ Implementation Roadmap

### Phase 1: Critical Fixes (Week 1-2)

1. **Config (Factor III)** - HIGH PRIORITY
   - [ ] Create `.env.example` with all variables
   - [ ] Remove JSON config files for environment settings
   - [ ] Update all services to read from environment
   - [ ] Update documentation

2. **Dev/Prod Parity (Factor X)** - HIGH PRIORITY
   - [ ] Create `docker-compose.dev.yml` with PostgreSQL
   - [ ] Update schema.prisma to support PostgreSQL
   - [ ] Document development setup with Docker
   - [ ] Test migrations on PostgreSQL

### Phase 2: Important Improvements (Week 3-4)

3. **Logs (Factor XI)** - MEDIUM PRIORITY
   - [ ] Remove all file-based logging
   - [ ] Implement structured JSON logging everywhere
   - [ ] Add request ID tracking
   - [ ] Document log aggregation setup

4. **Disposability (Factor IX)** - MEDIUM PRIORITY
   - [ ] Implement comprehensive graceful shutdown
   - [ ] Add startup time monitoring
   - [ ] Add health check endpoints
   - [ ] Test signal handling

### Phase 3: Documentation & Validation (Week 5)

5. **Documentation**
   - [ ] Update all docs with 12-factor compliance
   - [ ] Create deployment checklist
   - [ ] Document environment variables
   - [ ] Update README with best practices

6. **Testing**
   - [ ] Test deployments in all environments
   - [ ] Validate configuration management
   - [ ] Test graceful shutdown
   - [ ] Verify log aggregation

---

## üö® Anti-Patterns to Avoid

### ‚ùå Hardcoded Configuration
```typescript
// ‚ùå NEVER DO THIS
const config = {
  database: "postgresql://prod-server/db",
  port: 3000,
  apiKey: "EXAMPLE_FAKE_API_KEY_DO_NOT_USE",
};
```

### ‚ùå File-Based Logging
```typescript
// ‚ùå NEVER DO THIS
fs.appendFile("app.log", message);
winston.transports.File({ filename: "error.log" });
```

### ‚ùå Stateful Services
```typescript
// ‚ùå NEVER DO THIS
class Service {
  private cache = new Map(); // Won't work with multiple instances
}
```

### ‚ùå Mixed Environments
```bash
# ‚ùå NEVER DO THIS
# Development: SQLite
DATABASE_URL=file:./dev.db

# Production: PostgreSQL
DATABASE_URL=postgresql://...
```

---

## ‚úÖ Best Practices

### 1. Environment First
```bash
# Always use .env for local development
cp .env.example .env
nano .env
```

### 2. Docker for Backing Services
```bash
# Start PostgreSQL, RabbitMQ, etc.
docker-compose -f docker-compose.dev.yml up -d
```

### 3. Structured Logging
```typescript
// Use JSON for structured logs
logger.info("Event", { key: "value" });
```

### 4. Health Checks
```typescript
// Always provide health check endpoint
app.get("/health", (req, res) => {
  res.json({ status: "healthy", timestamp: new Date() });
});
```

### 5. Graceful Shutdown
```typescript
// Always handle SIGTERM and SIGINT
process.on("SIGTERM", shutdown);
process.on("SIGINT", shutdown);
```

---

## üéØ Success Criteria

‚úÖ **12 out of 12 factors fully compliant**

- All configuration from environment variables
- PostgreSQL in all environments
- Logs stream to stdout/stderr
- Graceful shutdown < 30 seconds
- Startup time < 3 seconds
- Zero secrets in version control
- Can deploy to any cloud platform

**Target: 12/12 Factors Fully Compliant**

---

## üìö Resources

- [The Twelve-Factor App](https://12factor.net/) - Official methodology
- [Environment Variables Best Practices](https://12factor.net/config)
- [Graceful Shutdown in Node.js](https://expressjs.com/en/advanced/healthcheck-graceful-shutdown.html)
- [PostgreSQL in Docker](https://hub.docker.com/_/postgres)

---

**Remember: Follow these principles religiously. They make your app portable, scalable, and cloud-native!** üöÄ