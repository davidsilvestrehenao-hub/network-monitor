---
description: Advanced Architectural Patterns and Implementation Guidelines
globs: "src/lib/**/*.{ts,tsx}"
alwaysApply: true
type: Auto Attached
---

# Advanced Architectural Patterns

## üèóÔ∏è **Perfect Loose Coupling Implementation**

This project implements **perfect loose coupling (10/10 score)** through advanced architectural patterns.

### **Core Principles**

- **Zero Direct Dependencies**: No service directly calls another service
- **Service Layer Architecture**: Routers call services, services call repositories
- **Repository Pattern**: Database operations abstracted through repository interfaces
- **Command/Query Separation**: Clear distinction between read and write operations
- **Interface-Based Design**: All services depend on abstractions, not concrete implementations

### **Service Layer Architecture**

The service layer is the **only layer** that routers should interact with. This maintains proper separation of concerns and loose coupling.

#### **Proper Layering**

```
tRPC Router ‚Üí Service Layer ‚Üí Repository Layer ‚Üí Database
     ‚Üì              ‚Üì              ‚Üì              ‚Üì
  Business      Business        Data Access    Database
   Logic         Logic           Contract      Layer
```

#### **Service Layer Benefits**

- **Business Logic Centralization**: All business rules in one place
- **Repository Abstraction**: Services hide data access complexity
- **Easy Testing**: Mock services for isolated testing
- **Maintainability**: Clear separation of responsibilities
- **Scalability**: Easy to add new features without affecting other layers

## üîß **Dependency Injection Patterns**

### **Service Registration**

```typescript
// ‚úÖ Good: Configuration-based service registration
[TYPES.ITargetRepository]: {
  factory: createServiceFactory<() => ITargetRepository>(
    container => new TargetRepository(
      container.get<IDatabaseService>(TYPES.IDatabaseService),
      container.get<ILogger>(TYPES.ILogger)
    )
  ),
  dependencies: [TYPES.IDatabaseService, TYPES.ILogger],
  singleton: true,
  description: "Target repository for database operations",
}

// ‚ùå Bad: Hardcoded service instantiation
const targetRepository = new TargetRepository(databaseService, logger);
```

### **Service Resolution**

```typescript
// ‚úÖ Good: Container-based resolution
const targetRepository = container.get<ITargetRepository>(
  TYPES.ITargetRepository
);

// ‚ùå Bad: Direct instantiation
const targetRepository = new TargetRepository(databaseService, logger);
```

## üéØ **Service Layer Implementation Patterns**

### **Router-Service Pattern**

```typescript
// ‚úÖ Good: Router calling service
export const createTarget = createCaller(
  CreateTargetSchema,
  async ({ input$, event$: _event$, session$ }) => {
    const ctx = createAppContext();
    const { name, address } = input$;

    // Router calls service
    const target = await ctx.services.monitor.createTarget({
      name,
      address,
      ownerId: session$.user.id,
    });

    return target;
  }
);

// ‚ùå Bad: Router calling repository directly
const target = await ctx.services.targetRepository.create(data);
```

### **Service-Repository Pattern**

```typescript
// ‚úÖ Good: Service calling repository
class MonitorService {
  constructor(private targetRepository: ITargetRepository) {}

  async createTarget(data: CreateTargetData): Promise<MonitoringTarget> {
    this.logger.debug("MonitorService: Creating target", data);

    // Service calls repository
    return await this.targetRepository.create(data);
  }
}

// ‚ùå Bad: Service calling database directly
const target = await this.databaseService.getClient().monitoringTarget.create({...});
```

### **Service Interface Design**

```typescript
// ‚úÖ Good: Complete service interface
export interface IMonitorService {
  // Target management
  createTarget(data: CreateTargetData): Promise<MonitoringTarget>;
  getTarget(id: string): Promise<MonitoringTarget | null>;
  getTargets(userId: string): Promise<MonitoringTarget[]>;
  updateTarget(id: string, data: UpdateTargetData): Promise<MonitoringTarget>;
  deleteTarget(id: string): Promise<void>;

  // Monitoring operations
  runSpeedTest(config: SpeedTestConfig): Promise<SpeedTestResultData>;
  startMonitoring(targetId: string, intervalMs: number): void;
  stopMonitoring(targetId: string): void;
  getActiveTargets(): string[];
  getTargetResults(
    targetId: string,
    limit?: number
  ): Promise<SpeedTestResult[]>;
}
```

## üéØ **Event-Driven Communication Patterns**

### **Event Emission**

```typescript
// ‚úÖ Good: Type-safe event emission
this.eventBus.emitTyped("TARGET_CREATE_REQUESTED", {
  name: data.name,
  address: data.address,
  ownerId: data.ownerId,
});

// ‚ùå Bad: Direct service calls
const target = await this.targetRepository.create(data);
```

### **Event Handling**

```typescript
// ‚úÖ Good: Centralized event handling
this.eventBus.on('TARGET_CREATE_REQUESTED', this.handleTargetCreateRequested.bind(this));

private async handleTargetCreateRequested(data: CreateTargetData) {
  try {
    const target = await this.targetRepository.create(data);
    this.eventBus.emit('TARGET_CREATED', target);
  } catch (error) {
    this.eventBus.emit('TARGET_CREATE_FAILED', { message: error.message });
  }
}
```

## üìä **Repository Pattern Implementation**

The repository pattern is a fundamental architectural pattern that abstracts data access logic and provides a uniform interface for accessing data sources. It ensures that the Prisma client never leaves the repository layer.

### **Repository Interface**

```typescript
// ‚úÖ Good: Repository interface
export interface ITargetRepository {
  findById(id: string): Promise<Target | null>;
  findByUserId(userId: string): Promise<Target[]>;
  create(data: CreateTargetData): Promise<Target>;
  update(id: string, data: UpdateTargetData): Promise<Target>;
  delete(id: string): Promise<void>;
  count(): Promise<number>;
  getAll(limit?: number, offset?: number): Promise<Target[]>;
}

// ‚ùå Bad: Direct Prisma usage
const target = await prisma.monitoringTarget.findUnique({ where: { id } });
```

### **Repository Implementation**

```typescript
// ‚úÖ Good: Repository implementation with data mapping
export class TargetRepository implements ITargetRepository {
  constructor(
    private databaseService: IDatabaseService,
    private logger: ILogger
  ) {}

  async findById(id: string): Promise<Target | null> {
    this.logger.debug("TargetRepository: Finding target by ID", { id });

    const target = await this.databaseService
      .getClient()
      .monitoringTarget.findUnique({
        where: { id },
        include: { speedTestResults: true, alertRules: true },
      });

    return target ? this.mapToTarget(target) : null;
  }

  private mapToTarget(prismaTarget: PrismaTarget): Target {
    return {
      id: prismaTarget.id,
      name: prismaTarget.name,
      address: prismaTarget.address,
      speedTestResults:
        prismaTarget.speedTestResults?.map(this.mapToSpeedTestResult) || [],
      alertRules: prismaTarget.alertRules?.map(this.mapToAlertRule) || [],
    };
  }
}
```

### **Repository Responsibilities**

- **Data Abstraction**: Hide database implementation details from business logic
- **Type Mapping**: Convert between Prisma models and domain types
- **Query Optimization**: Provide high-level methods for common operations
- **Error Handling**: Handle database-specific errors gracefully
- **Logging**: Log all database operations for debugging
- **Testing Support**: Enable easy mocking for unit tests

## üé® **Command/Query Pattern Implementation**

### **Command Interface**

```typescript
// ‚úÖ Good: Command interface
export interface CreateTargetCommand {
  name: string;
  address: string;
}

export interface ICommandQueryService {
  createTarget(command: CreateTargetCommand): Promise<Target>;
  updateTarget(command: UpdateTargetCommand): Promise<Target>;
  deleteTarget(command: DeleteTargetCommand): Promise<void>;
}
```

### **Command Implementation**

```typescript
// ‚úÖ Good: Command implementation
async createTarget(command: CreateTargetCommand): Promise<Target> {
  this.logger.debug("CommandQuery: Creating target", command);

  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error("Target creation timeout"));
    }, 10000);

    this.eventBus.once("TARGET_CREATED", (target: Target) => {
      clearTimeout(timeout);
      resolve(target);
    });

    this.eventBus.once("TARGET_CREATE_FAILED", (error: { error: string }) => {
      clearTimeout(timeout);
      reject(new Error(error.error));
    });

    this.eventBus.emitTyped("TARGET_CREATE_REQUESTED", command);
  });
}
```

## ‚öôÔ∏è **Configuration Management Patterns**

### **Service Configuration**

```typescript
// ‚úÖ Good: Configuration-based service definition
export const baseServiceConfig: ServiceConfig = {
  [TYPES.ITargetRepository]: {
    factory: createServiceFactory<() => ITargetRepository>(
      container =>
        new TargetRepository(
          container.get<IDatabaseService>(TYPES.IDatabaseService),
          container.get<ILogger>(TYPES.ILogger)
        )
    ),
    dependencies: [TYPES.IDatabaseService, TYPES.ILogger],
    singleton: true,
    description: "Target repository for database operations",
  },
};
```

### **Environment-Specific Configuration**

```typescript
// ‚úÖ Good: Environment-specific overrides
export const testConfig: ServiceConfig = {
  [TYPES.ITargetRepository]: {
    factory: createServiceFactory<() => ITargetRepository>(
      () => new MockTargetRepository()
    ),
    dependencies: [],
    singleton: true,
    description: "Mock target repository for testing",
  },
};
```

## üß™ **Testing Patterns**

### **Mock Repository Implementation**

```typescript
// ‚úÖ Good: Mock repository with seeded data
export class MockTargetRepository implements ITargetRepository {
  private targets: Target[] = [];

  constructor(private logger?: ILogger) {
    // Auto-seed with test data
    this.seedTargets(TestDataSeeder.generateTargets());
  }

  async findById(id: string): Promise<Target | null> {
    this.logger?.debug("MockTargetRepository: Finding target by ID", { id });
    return this.targets.find(t => t.id === id) || null;
  }

  async create(data: CreateTargetData): Promise<Target> {
    this.logger?.debug("MockTargetRepository: Creating target", data);
    const target: Target = {
      id: `target-${Date.now()}`,
      name: data.name,
      address: data.address,
      speedTestResults: [],
      alertRules: [],
    };
    this.targets.push(target);
    return target;
  }

  // Seeding method for test data
  seedTargets(targets: Target[]): void {
    this.targets = targets;
  }
}
```

### **Mock Repository Benefits**

- **Test Data Seeding**: Pre-populate with realistic test data
- **In-Memory Storage**: Fast, isolated testing without database dependencies
- **Predictable Behavior**: Controlled test scenarios and edge cases
- **Development**: Easy development without database setup
- **Performance**: No database I/O overhead during testing

### **Test Configuration**

```typescript
// ‚úÖ Good: Test-specific configuration
export const testFrontendConfig: FrontendServiceConfig = {
  logger: { level: LogLevel.DEBUG, useMock: false },
  performanceMonitor: { useMock: true },
  cacheManager: { useMock: true },
  pwaService: { useMock: true },
  apiClient: { useMock: true },
  eventBus: { useMock: false },
  commandQuery: { useMock: false },
};
```

## üö´ **Anti-Patterns to Avoid**

### **Service Layer Violations**

```typescript
// ‚ùå Bad: Router calling repository directly
export const createTarget = createCaller(
  CreateTargetSchema,
  async ({ input$, event$: _event$, session$ }) => {
    const ctx = createAppContext();
    const { name, address } = input$;

    // Wrong: Router calling repository directly
    const target = await ctx.services.targetRepository.create({
      name,
      address,
      ownerId: session$.user.id,
    });

    return target;
  }
);

// ‚úÖ Good: Router calling service
export const createTarget = createCaller(
  CreateTargetSchema,
  async ({ input$, event$: _event$, session$ }) => {
    const ctx = createAppContext();
    const { name, address } = input$;

    // Correct: Router calling service
    const target = await ctx.services.monitor.createTarget({
      name,
      address,
      ownerId: session$.user.id,
    });

    return target;
  }
);
```

### **Tight Coupling Anti-Patterns**

```typescript
// ‚ùå Bad: Direct service calls
class MonitorService {
  constructor(private alertingService: AlertingService) {}

  async runTest() {
    const result = await this.speedTest();
    await this.alertingService.checkRules(result); // Direct call
  }
}

// ‚úÖ Good: Event-driven communication
class MonitorService {
  constructor(private eventBus: IEventBus) {}

  async runTest() {
    const result = await this.speedTest();
    this.eventBus.emit("TEST_COMPLETED", result); // Event emission
  }
}
```

### **Database Access Anti-Patterns**

```typescript
// ‚ùå Bad: Direct Prisma usage
class TargetService {
  async getTarget(id: string) {
    return await prisma.monitoringTarget.findUnique({ where: { id } });
  }
}

// ‚úÖ Good: Repository pattern
class TargetService {
  constructor(private targetRepository: ITargetRepository) {}

  async getTarget(id: string) {
    return await this.targetRepository.findById(id);
  }
}
```

## ‚úÖ **Best Practices Summary**

1. **Always use interfaces** for service contracts
2. **Never directly instantiate services** - use DI container
3. **Maintain proper layering**: Router ‚Üí Service ‚Üí Repository ‚Üí Database
4. **Never skip layers** - routers should only call services, not repositories
5. **Communicate via events** instead of direct calls
6. **Use repository pattern** for all database operations
7. **Separate commands from queries** in data flow
8. **Configure services** via configuration files
9. **Provide mock implementations** for all services
10. **Write comprehensive tests** for all functionality
11. **Maintain type safety** throughout the system
12. **Follow the single responsibility principle**

Remember: These patterns ensure **perfect loose coupling** and make the system highly maintainable, testable, and scalable. The service layer architecture is crucial for maintaining proper separation of concerns.
