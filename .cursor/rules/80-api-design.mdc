---
description: tRPC API Design Patterns and Standards
globs: "apps/web/src/server/trpc/**/*.ts"
alwaysApply: true
type: Auto Attached
---

# tRPC API Design Patterns

## 1. Philosophy: Type Safety First

The entire API is built with tRPC to ensure end-to-end type safety between the backend and frontend. There is no REST API. The frontend calls backend procedures as if they were local functions.

## 2. Defining Procedures

All API procedures are defined as part of the `appRouter` in `apps/web/src/server/trpc/router.ts`.

- **`query`**: For read-only operations. Analogous to a `GET` request.
- **`mutation`**: For write operations (create, update, delete). Analogous to `POST`, `PUT`, or `DELETE`.

```typescript
import { initTRPC } from "@trpc/server";
import { z } from "zod";

const t = initTRPC.create();

export const appRouter = t.router({
  // A public query procedure
  hello: t.procedure.query(() => {
    return "Hello, world!";
  }),

  // A mutation procedure with input validation
  createTarget: t.procedure
    .input(z.object({ name: z.string() }))
    .mutation(({ input }) => {
      // Calls a service to create the target
      // const newTarget = await targetService.create({ name: input.name });
      // return newTarget;
      return { id: "123", name: input.name }; // returns a typed object
    }),
});
```

## 3. Input Validation with Zod

- **Always validate inputs.** Every procedure that accepts input must define a validator using `zod`.
- This ensures data is in the correct format before it hits your service layer, preventing a large class of errors.

```typescript
// ✅ Good: Procedure with strong input validation
createUser: t.procedure
  .input(
    z.object({
      name: z.string().min(3),
      email: z.string().email(),
    }),
  )
  .mutation(({ input }) => {
    // `input` is guaranteed to be { name: string, email: string }
    return userService.create(input);
  });

// ❌ Bad: Procedure with no input validation
createUser: t.procedure.mutation(({ input }) => {
  // `input` is `unknown` here, which is unsafe.
  return userService.create(input as any);
});
```

## 4. Error Handling

- To throw an error from a tRPC procedure, use the `TRPCError` class.
- This allows you to provide a specific error code and message that the client can interpret.

```typescript
import { TRPCError } from "@trpc/server";

// ...

getTarget: t.procedure
  .input(z.string())
  .query(async ({ input: id }) => {
    const target = await targetService.getById(id);

    if (!target) {
      // This error will be sent to the client in a structured way
      throw new TRPCError({
        code: "NOT_FOUND",
        message: `Target with ID '${id}' not found.`,
      });
    }

    return target;
  });
```

## 5. Context (`createContext`)

The `createContext` function in the tRPC handler (`apps/web/src/routes/api/trpc/[...trpc].ts`) is used to provide context to all procedures. This is the correct place to inject:

- Database connections
- User session information
- Service instances from a DI container

This avoids passing them as arguments to every procedure and makes dependencies explicit.