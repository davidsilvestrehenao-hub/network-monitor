---
description: Repository Pattern Implementation Guidelines
globs: "src/lib/services/**/*.ts"
alwaysApply: true
type: Auto Attached
---

# Repository Pattern Implementation

## 🎯 **Core Principles**

The repository pattern is a fundamental architectural pattern that abstracts data access logic and provides a uniform interface for accessing data sources. It ensures that the Prisma client never leaves the repository layer.

### **Key Rules**

1. **Prisma Isolation**: The Prisma client should never be used outside of repository implementations
2. **Type Mapping**: All repository methods must return domain types, not raw Prisma models
3. **Interface-First**: Define repository interfaces before implementations
4. **Mock Support**: Every repository must have a corresponding mock implementation
5. **Data Abstraction**: Hide database implementation details from business logic

## 📁 **Repository Structure**

```
src/lib/services/
├── interfaces/          # Repository contracts
│   ├── ITargetRepository.ts
│   ├── ISpeedTestRepository.ts
│   ├── IAlertRepository.ts
│   ├── INotificationRepository.ts
│   └── IUserRepository.ts
├── concrete/            # Production implementations
│   ├── TargetRepository.ts
│   ├── SpeedTestRepository.ts
│   ├── AlertRepository.ts
│   ├── NotificationRepository.ts
│   └── UserRepository.ts
└── mocks/              # Test implementations
    ├── MockTargetRepository.ts
    ├── MockSpeedTestRepository.ts
    ├── MockAlertRepository.ts
    ├── MockNotificationRepository.ts
    └── MockUserRepository.ts
```

## 🔧 **Repository Interface Pattern**

```typescript
// ✅ Good: Repository interface
export interface ITargetRepository {
  // Query methods
  findById(id: string): Promise<Target | null>;
  findByUserId(userId: string): Promise<Target[]>;
  getAll(limit?: number, offset?: number): Promise<Target[]>;
  count(): Promise<number>;

  // Command methods
  create(data: CreateTargetData): Promise<Target>;
  update(id: string, data: UpdateTargetData): Promise<Target>;
  delete(id: string): Promise<void>;
}

// ❌ Bad: Direct Prisma usage in business logic
const target = await prisma.monitoringTarget.findUnique({ where: { id } });
```

## 🏗️ **Repository Implementation Pattern**

```typescript
// ✅ Good: Repository implementation with data mapping
export class TargetRepository implements ITargetRepository {
  constructor(
    private databaseService: IDatabaseService,
    private logger: ILogger
  ) {}

  async findById(id: string): Promise<Target | null> {
    this.logger.debug("TargetRepository: Finding target by ID", { id });

    const target = await this.databaseService
      .getClient()
      .monitoringTarget.findUnique({
        where: { id },
        include: { speedTestResults: true, alertRules: true },
      });

    return target ? this.mapToTarget(target) : null;
  }

  private mapToTarget(prismaTarget: PrismaTarget): Target {
    return {
      id: prismaTarget.id,
      name: prismaTarget.name,
      address: prismaTarget.address,
      speedTestResults:
        prismaTarget.speedTestResults?.map(this.mapToSpeedTestResult) || [],
      alertRules: prismaTarget.alertRules?.map(this.mapToAlertRule) || [],
    };
  }
}
```

## 🧪 **Mock Repository Pattern**

```typescript
// ✅ Good: Mock repository with seeded data
export class MockTargetRepository implements ITargetRepository {
  private targets: Target[] = [];

  constructor(private logger?: ILogger) {
    // Auto-seed with test data
    this.seedTargets(TestDataSeeder.generateTargets());
  }

  async findById(id: string): Promise<Target | null> {
    this.logger?.debug("MockTargetRepository: Finding target by ID", { id });
    return this.targets.find(t => t.id === id) || null;
  }

  async create(data: CreateTargetData): Promise<Target> {
    this.logger?.debug("MockTargetRepository: Creating target", data);
    const target: Target = {
      id: `target-${Date.now()}`,
      name: data.name,
      address: data.address,
      speedTestResults: [],
      alertRules: [],
    };
    this.targets.push(target);
    return target;
  }

  // Seeding method for test data
  seedTargets(targets: Target[]): void {
    this.targets = targets;
  }
}
```

## 📋 **Repository Responsibilities**

### **Data Abstraction**

- Hide database implementation details from business logic
- Provide high-level methods for common data operations
- Handle database-specific errors and convert to domain errors

### **Type Mapping**

- Convert between Prisma models and domain types
- Ensure all returned data matches expected interfaces
- Handle optional fields and null values appropriately

### **Logging**

- Log all database operations for debugging and monitoring
- Include relevant context (IDs, operation type, etc.)
- Use appropriate log levels (debug, info, error)

### **Error Handling**

- Catch database-specific errors
- Convert to domain-appropriate error messages
- Log errors with context for debugging

## 🚫 **Anti-Patterns to Avoid**

### **Direct Prisma Usage**

```typescript
// ❌ Bad: Direct Prisma usage in business logic
class MonitorService {
  async getTarget(id: string) {
    return await prisma.monitoringTarget.findUnique({ where: { id } });
  }
}

// ✅ Good: Using repository pattern
class MonitorService {
  constructor(private targetRepository: ITargetRepository) {}

  async getTarget(id: string) {
    return await this.targetRepository.findById(id);
  }
}
```

### **Raw Prisma Models**

```typescript
// ❌ Bad: Returning raw Prisma models
async findById(id: string): Promise<PrismaTarget | null> {
  return await this.databaseService.getClient().monitoringTarget.findUnique({...});
}

// ✅ Good: Returning domain types
async findById(id: string): Promise<Target | null> {
  const prismaTarget = await this.databaseService.getClient().monitoringTarget.findUnique({...});
  return prismaTarget ? this.mapToTarget(prismaTarget) : null;
}
```

### **Missing Mock Implementations**

```typescript
// ❌ Bad: No mock implementation
// Only concrete repository exists

// ✅ Good: Both concrete and mock implementations
export class TargetRepository implements ITargetRepository { ... }
export class MockTargetRepository implements ITargetRepository { ... }
```

## ✅ **Best Practices**

### **Interface Design**

- Use descriptive method names that clearly indicate their purpose
- Include both query and command methods
- Provide pagination support for list methods
- Include count methods for statistics

### **Data Mapping**

- Create private mapping methods for each Prisma model
- Handle optional fields gracefully
- Map related data (includes) to domain objects
- Use consistent naming between Prisma and domain models

### **Error Handling**

- Log all database operations with context
- Catch and convert database errors to domain errors
- Provide meaningful error messages
- Include operation context in error logs

### **Testing Support**

- Provide mock implementations for all repositories
- Support data seeding for test scenarios
- Make mock repositories behave predictably
- Include logging in mock implementations for debugging

## 🎯 **Quality Standards**

### **Required Implementation**

- Every repository must have an interface
- Every repository must have a concrete implementation
- Every repository must have a mock implementation
- All methods must return domain types, not Prisma models
- All database operations must be logged

### **Code Review Checklist**

- [ ] Repository interface is well-defined
- [ ] Concrete implementation maps Prisma models to domain types
- [ ] Mock implementation provides test data seeding
- [ ] All methods are properly logged
- [ ] Error handling is appropriate
- [ ] No direct Prisma usage outside repositories
- [ ] Type safety is maintained throughout

Remember: **The repository pattern is essential for maintaining loose coupling and testability. The Prisma client should never leave the repository layer.**
