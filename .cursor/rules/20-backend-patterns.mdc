---
alwaysApply: true
type: Auto Attached
globs: "packages/**/*.ts,apps/web/src/server/**/*.ts"
description: Provides rules for building tRPC backend procedures and services.
---

# Backend Development Patterns

## 1. Core Pattern: Router → Service → Repository

All backend logic must follow this strict layering. **Never skip layers.**

1.  **Router (tRPC Procedure)**: The entry point is a tRPC procedure defined in the `appRouter` (`apps/web/src/server/trpc/router.ts`). Its only job is to parse input and call the appropriate method on a **Service**.

2.  **Service**: Services contain all business logic and are located in the `packages/*` workspaces (e.g., `packages/monitor/src/services/MonitorService.ts`). They orchestrate operations, calling one or more repositories to fulfill a request.

3.  **Repository**: Repositories handle all database communication and are located in `packages/database/src/repositories/`. They are the only place where the Prisma client is used.

## 2. Implementation Example

```typescript
// 1. tRPC Router Procedure (The "Router")
// File: apps/web/src/server/trpc/router.ts

import { monitorService } from ".../some-service-resolver"; // Services should be injected

const t = initTRPC.create();

export const appRouter = t.router({
  getTargetById: t.procedure
    .input(z.object({ id: z.string() }))
    .query(({ input }) => {
      // ✅ Correct: The procedure calls a service.
      return monitorService.getTarget(input.id);
    }),
});
```

```typescript
// 2. Service (Business Logic)
// File: packages/monitor/src/services/MonitorService.ts

import type { ITargetRepository } from "@network-monitor/database";

export class MonitorService {
  private targetRepository: ITargetRepository;

  constructor(targetRepository: ITargetRepository) {
    this.targetRepository = targetRepository; // Dependency is injected
  }

  async getTarget(id: string) {
    // ✅ Correct: The service calls a repository.
    // It can also contain more complex business logic.
    return this.targetRepository.findById(id);
  }
}
```

```typescript
// 3. Repository (Data Access)
// File: packages/database/src/repositories/TargetRepository.ts

import type { IDatabaseService } from "../infrastructure";

export class TargetRepository implements ITargetRepository {
  private db: IDatabaseService;

  constructor(db: IDatabaseService) {
    this.db = db;
  }

  async findById(id: string) {
    // ✅ Correct: The repository uses the Prisma client.
    const target = await this.db.getClient().monitoringTarget.findUnique({ where: { id } });
    // It must also map the Prisma model to a domain model.
    return this.mapToDomain(target);
  }

  private mapToDomain(target: any) { /* ... */ }
}
```

## 3. Interface Implementation Patterns

### **Repository Interface Hierarchy**

All repository interfaces **MUST** extend the base `IRepository` interface:

```typescript
// ✅ Correct: Repository extends base interface
export interface ITargetRepository
  extends IRepository<Target, CreateTargetData, UpdateTargetData> {
  // Domain-specific query methods
  findByUserId(userId: string): Promise<Target[]>;
  
  // Domain-specific command methods
  updateStatus(id: string, status: string): Promise<Target>;
}

// ❌ Incorrect: Repository without base interface
export interface ITargetRepository {
  findById(id: string): Promise<Target | null>;
  // ... missing base CRUD methods
}
```

**Base Repository Interface Methods:**
- `findById(id: string | number): Promise<T | null>`
- `getAll(limit?: number, offset?: number): Promise<T[]>`
- `create(data: CreateDto): Promise<T>`
- `update(id: string | number, data: UpdateDto): Promise<T>`
- `delete(id: string | number): Promise<void>`
- `count(): Promise<number>`

### **Service Interface Hierarchy**

All service interfaces **MUST** extend the base `IService` interface:

```typescript
// ✅ Correct: Service extends base interface
export interface IMonitorService
  extends IUserOwnedService<Target, CreateTargetData, UpdateTargetData>,
    IObservableService,
    IBackgroundService {
  // Domain-specific methods
  startMonitoring(targetId: string, intervalMs: number): void;
  stopMonitoring(targetId: string): void;
}

// ❌ Incorrect: Service without base interface
export interface IMonitorService {
  startMonitoring(targetId: string, intervalMs: number): void;
  // ... missing base CRUD methods
}
```

**Base Service Interface Methods:**
- `getById(id: string | number): Promise<T | null>`
- `getAll(limit?: number, offset?: number): Promise<T[]>`
- `create(data: CreateDto): Promise<T>`
- `update(id: string | number, data: UpdateDto): Promise<T>`
- `delete(id: string | number): Promise<void>`

**Specialized Service Interfaces:**
- `IUserOwnedService<T, CreateDto, UpdateDto>` - Adds `getByUserId(userId: string)`
- `IObservableService` - Adds `on()`, `off()`, `emit()` for event handling
- `IBackgroundService` - Adds `start()`, `stop()` for background tasks

### **API Client Interface Hierarchy**

All API client interfaces **MUST** extend the base `IAPIClient` interface:

```typescript
// ✅ Correct: API client extends base interface
export interface IAPIClient extends BaseIAPIClient {
  // Domain-specific methods
  createTarget(data: CreateTargetData): Promise<Target>;
  getTargets(): Promise<Target[]>;
}

// ❌ Incorrect: API client without base interface
export interface IAPIClient {
  createTarget(data: CreateTargetData): Promise<Target>;
  // ... missing base connection/request methods
}
```

**Base API Client Interface Methods:**
- `connect(): Promise<void>`
- `disconnect(): Promise<void>`
- `isConnected(): boolean`
- `request<T>(endpoint: string, options?: RequestOptions): Promise<T>`
- `get<T>(endpoint: string, options?: RequestOptions): Promise<T>`
- `post<T>(endpoint: string, data?: unknown, options?: RequestOptions): Promise<T>`
- `put<T>(endpoint: string, data?: unknown, options?: RequestOptions): Promise<T>`
- `patch<T>(endpoint: string, data?: unknown, options?: RequestOptions): Promise<T>`
- `delete<T>(endpoint: string, options?: RequestOptions): Promise<T>`
- `setErrorHandler(handler: (error: APIError) => void): void`
- `setRetryPolicy(policy: RetryPolicy): void`
- `setAuthToken(token: string): void`
- `clearAuthToken(): void`
- `isAuthenticated(): boolean`

### **Concrete Implementation Requirements**

All concrete implementations **MUST** implement both base and domain-specific methods:

```typescript
// ✅ Correct: Concrete service implements all methods
export class MonitorService implements IMonitorService {
  // Base IService methods
  async getById(id: string | number): Promise<Target | null> {
    return this.targetRepository.findById(typeof id === "string" ? id : id.toString());
  }

  async getAll(limit?: number, offset?: number): Promise<Target[]> {
    return this.targetRepository.getAll(limit, offset);
  }

  async create(data: CreateTargetData): Promise<Target> {
    return this.targetRepository.create(data);
  }

  async update(id: string | number, data: UpdateTargetData): Promise<Target> {
    return this.targetRepository.update(typeof id === "string" ? id : id.toString(), data);
  }

  async delete(id: string | number): Promise<void> {
    return this.targetRepository.delete(typeof id === "string" ? id : id.toString());
  }

  // IUserOwnedService methods
  async getByUserId(userId: string): Promise<Target[]> {
    return this.targetRepository.findByUserId(userId);
  }

  // IObservableService methods
  on<T = unknown>(event: string, handler: (data?: T) => void): void {
    this.eventBus.on(event, handler);
  }

  off<T = unknown>(event: string, handler: (data?: T) => void): void {
    this.eventBus.off(event, handler);
  }

  emit<T = unknown>(event: string, data?: T): void {
    this.eventBus.emit(event, data);
  }

  // IBackgroundService methods
  async start(): Promise<void> {
    // Start background monitoring
  }

  async stop(): Promise<void> {
    // Stop background monitoring
  }

  // Domain-specific methods
  startMonitoring(targetId: string, intervalMs: number): void {
    // Implementation
  }

  stopMonitoring(targetId: string): void {
    // Implementation
  }
}
```

## 4. Key Rules

- **Interface Polymorphism**: All interfaces MUST extend their appropriate base interfaces
- **Method Delegation**: Domain-specific methods should delegate to base methods when possible
- **Type Safety**: Use generic type parameters for compile-time safety
- **Authentication**: Protect tRPC procedures by default using middleware
- **Dependency Injection**: Services and repositories must receive their dependencies via DI container
- **Interface-First Design**: Define interfaces before implementations to ensure loose coupling
- **Prisma Isolation**: The Prisma client must only be used inside the repository layer
- **Event Emission**: Services should emit events for domain-specific operations
- **Error Handling**: All methods should include proper error handling and logging
