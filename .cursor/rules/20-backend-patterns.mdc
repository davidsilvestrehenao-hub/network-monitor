---
alwaysApply: true
type: Auto Attached
globs: "packages/**/*.ts,apps/web/src/server/**/*.ts"
description: Provides rules for building tRPC backend procedures and services.
---

# Backend Development Patterns

## 1. Core Pattern: Router → Service → Repository

All backend logic must follow this strict layering. **Never skip layers.**

1.  **Router (tRPC Procedure)**: The entry point is a tRPC procedure defined in the `appRouter` (`apps/web/src/server/trpc/router.ts`). Its only job is to parse input and call the appropriate method on a **Service**.

2.  **Service**: Services contain all business logic and are located in the `packages/*` workspaces (e.g., `packages/monitor/src/services/MonitorService.ts`). They orchestrate operations, calling one or more repositories to fulfill a request.

3.  **Repository**: Repositories handle all database communication and are located in `packages/database/src/repositories/`. They are the only place where the Prisma client is used.

## 2. Implementation Example

```typescript
// 1. tRPC Router Procedure (The "Router")
// File: apps/web/src/server/trpc/router.ts

import { monitorService } from ".../some-service-resolver"; // Services should be injected

const t = initTRPC.create();

export const appRouter = t.router({
  getTargetById: t.procedure
    .input(z.object({ id: z.string() }))
    .query(({ input }) => {
      // ✅ Correct: The procedure calls a service.
      return monitorService.getTarget(input.id);
    }),
});
```

```typescript
// 2. Service (Business Logic)
// File: packages/monitor/src/services/MonitorService.ts

import type { ITargetRepository } from "@network-monitor/database";

export class MonitorService {
  private targetRepository: ITargetRepository;

  constructor(targetRepository: ITargetRepository) {
    this.targetRepository = targetRepository; // Dependency is injected
  }

  async getTarget(id: string) {
    // ✅ Correct: The service calls a repository.
    // It can also contain more complex business logic.
    return this.targetRepository.findById(id);
  }
}
```

```typescript
// 3. Repository (Data Access)
// File: packages/database/src/repositories/TargetRepository.ts

import type { IDatabaseService } from "../infrastructure";

export class TargetRepository implements ITargetRepository {
  private db: IDatabaseService;

  constructor(db: IDatabaseService) {
    this.db = db;
  }

  async findById(id: string) {
    // ✅ Correct: The repository uses the Prisma client.
    const target = await this.db.getClient().monitoringTarget.findUnique({ where: { id } });
    // It must also map the Prisma model to a domain model.
    return this.mapToDomain(target);
  }

  private mapToDomain(target: any) { /* ... */ }
}
```

## 3. Key Rules

- **Authentication**: Protect tRPC procedures by default using middleware.
- **Dependency Injection**: Services and repositories must receive their dependencies (like other services or the DB client) via a DI container, not by instantiating them directly.
- **Interface-First Design**: Define interfaces for services and repositories (`IMonitorService`, `ITargetRepository`) to ensure loose coupling.
- **Prisma Isolation**: The Prisma client must only be used inside the repository layer.
