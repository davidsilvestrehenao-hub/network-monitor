---
description: Enforces the Dependency Injection and Event Bus architecture.
globs:"src/server/{services,lib,trpc}/**/*.ts"
alwaysApply: true
type: Auto Attached
---

# Architecture: Dependency Injection & Event-Driven Services

## 1. Advanced Dependency Injection (DI)

The application uses a **custom flexible container system** for Dependency Injection with configuration-based service resolution.

### 🔧 **Container System**

- **Flexible Container**: Located at `src/lib/container/flexible-container.ts`
- **Configuration-Based**: Service implementations loaded from `service-config.json` in project root
- **Environment-Specific**: Different configs for development, test, production
- **Type-Safe Factories**: Compile-time and runtime type safety for service creation

### 📋 **DI Rules**

- **Do not manually instantiate classes.** All services must be resolved from the container
- **Program to Interfaces.** Services should depend on abstractions (interfaces like `IEventBus`), not concrete implementations
- **Configuration-Driven:** Service implementations determined by configuration files, not hardcoded
- **Service Registry:** Use the service registry for dynamic service loading

### 🏗️ **Service Organization**

```
src/lib/services/
├── interfaces/          # Service contracts
├── concrete/            # Production implementations
└── mocks/              # Test implementations
```

## 2. Event-Driven Architecture

The system achieves **perfect loose coupling (10/10 score)** through event-driven communication.

### 🎯 **Event Bus System**

- **Backend Events**: `IEventBus` for inter-service communication
- **Frontend Events**: `IEventBus` for component communication
- **Type-Safe Events**: `FrontendEvents` interface for compile-time safety
- **Event Handlers**: Centralized processing in `EventHandlerService`

### 📊 **Event Flow Patterns**

#### Backend Event Flow

```
tRPC Router → Event Bus → Event Handler Service → Repository → Database
     ↓              ↓              ↓                ↓
   Events      Event Bus    Service Layer    Data Layer
```

#### Frontend Event Flow

```
Component → Command/Query Service → Event Bus → API Client → Backend
     ↓              ↓                ↓           ↓
  Commands    Event-Driven      Event Bus    HTTP/WebSocket
```

### 🚫 **Anti-Patterns to Avoid**

- **Direct Service Calls**: Never call services directly
- **Tight Coupling**: Services must not know about each other
- **Synchronous Dependencies**: Use events for async communication

### ✅ **Best Practices**

- **Event-Driven Communication**: All inter-service communication via events
- **Repository Pattern**: Database operations through repository interfaces
- **Command/Query Separation**: Clear distinction between read and write operations
- **Interface-Based Design**: Depend on abstractions, not concrete implementations

## 3. Example Event Flow

### Backend Example

1. `tRPC Router` receives request
2. Emits `TARGET_CREATE_REQUESTED` event
3. `EventHandlerService` processes event
4. Calls `TargetRepository.create()`
5. Emits `TARGET_CREATED` response event
6. Router resolves with result

### Frontend Example

1. `Component` calls `commandQuery.createTarget()`
2. `CommandQueryService` emits `TARGET_CREATE_REQUESTED` event
3. Waits for `TARGET_CREATED` response event
4. Resolves promise with result
5. Component updates UI reactively

## 4. Configuration Management

### ⚙️ **Service Configuration**

- **Active Config**: `service-config.json` in project root
- **Environment Configs**: `src/lib/container/configs/` directory
- **Dynamic Switching**: Runtime service implementation switching
- **Type Safety**: Full TypeScript support for all configurations

### 🔄 **Configuration Switching**

```bash
# Switch to test configuration
bun run switch-config test

# Switch to production configuration
bun run switch-config production

# Switch to custom configuration
bun run switch-config custom
```

## 5. Quality Standards

### 🎯 **Architecture Score: 10/10**

- **Zero Direct Dependencies**: No service directly calls another service
- **Event-Driven Communication**: All inter-service communication via events
- **Repository Pattern**: Database operations fully abstracted
- **Command/Query Separation**: Clear separation of read/write operations
- **Type Safety**: Full TypeScript support throughout
- **Testability**: Easy to mock and test individual components
- **Scalability**: Easy to add new services without affecting existing ones
